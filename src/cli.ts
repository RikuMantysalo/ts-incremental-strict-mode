import execa from 'execa';
import findUp from 'find-up';
import globby from 'globby';
import tempy from 'tempy';
import path from 'path';
import fs from 'fs';
import { generateTempConfig } from './baseConfig';

export type FilePath = string;

const logTSConfigPath = (tsConfigPath: FilePath): void =>
    console.log(`Using tsconfig from ${tsConfigPath}`);

export const resolveTSConfig = async (): Promise<string> => {
    const resolvedConfigPath = await findUp('tsconfig.json');
    if (resolvedConfigPath) {
        logTSConfigPath(resolvedConfigPath);
        return resolvedConfigPath;
    } else {
        throw new Error('Could not find a tsconfig.json!');
    }
};

export const getTSConfig = async (configPath?: FilePath): Promise<FilePath> => {
    if (configPath) {
        fs.access(configPath, err => {
            if (err) {
                throw err;
            }
            logTSConfigPath(configPath);
        });
        return configPath;
    } else {
        return await resolveTSConfig();
    }
};

// Gets absolute paths for the files supplied via CLI
// Example: ts-incremental-strict-mode src/file1.ts
// Returns absolute path for file1.ts
const getAbsoluteFilePaths = (files: FilePath[]): FilePath[] => {
    return files.map(filename => path.resolve(filename));
};

// Creates a temporary tsconfig which extends an existing configuration
// but overrides the included files, to include only the files specified
// via the CLI.
export const createTempTSConfig = async (
    files: FilePath[],
    configPath?: FilePath
): Promise<FilePath | undefined> => {
    const tempConfigFilePath = tempy.file({ name: 'tsconfig.json' });
    const writeFileCallback = (error: NodeJS.ErrnoException | null): void => {
        if (error) {
            throw new Error('Failed to create a temporary tsconfig!');
        }
    };
    const tsConfigPath = await getTSConfig(configPath);
    const relativeTSConfigPath = path.relative(tempConfigFilePath, tsConfigPath);
    fs.writeFile(
        tempConfigFilePath,
        generateTempConfig(relativeTSConfigPath, getAbsoluteFilePaths(await globby(files))),
        writeFileCallback
    );
    return tempConfigFilePath;
};

// Runs the typescript compiler using the temporary configuration
// generated by createTempTSConfig
export const typeCheck = async (
    tscArgs: string[],
    files: FilePath[],
    verboseMode: boolean,
    configPath?: FilePath
): Promise<void> => {
    try {
        const tempConfigPath = await createTempTSConfig(files, configPath);
        if (tempConfigPath) {
            const filePaths = getAbsoluteFilePaths(await globby(files));
            if (verboseMode) {
                console.log('Type checking:');
                filePaths.forEach(file => console.log(file));
            }
            await execa('tsc', [...tscArgs, '--noEmit', '--project', tempConfigPath], {
                all: true
            });
        }
    } catch (error) {
        const { all } = error;
        if (all) {
            throw new Error(all);
        }
        throw error;
    }
};
